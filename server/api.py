import json
import requests
import os

from flask import Blueprint, jsonify, redirect, request, current_app, send_file, make_response, send_file
from flask_cors import CORS, cross_origin
from flask_socketio import emit
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from flask_apscheduler import APScheduler

from datetime import datetime, timedelta
from io import BytesIO

import firebase_admin
from firebase_admin import credentials, firestore

from botocore.exceptions import ClientError
from server.extensions import multipart_download_boto3, multipart_upload_boto3

import sendgrid
from sendgrid.helpers.mail import Mail

from . import atomic_orbital, electron_density
from .extensions import socketio
from dotenv import load_dotenv
load_dotenv()

import stripe

# Initialize Firebase credentials
cred = credentials.Certificate("server/service_account.json")
firebase_admin.initialize_app(cred)

socketio_bp = Blueprint('socketio', __name__)

db = firestore.client()
scheduler = APScheduler()

STRIPE_WEBHOOK_SECRET = os.environ.get('STRIPE_WEBHOOK_SECRET')
REVENUECAT_STRIPE_API_KEY = os.environ.get('REVENUECAT_STRIPE_API_KEY')

YOUR_DOMAIN = 'https://electronvisual.org/membership'

if os.environ.get("FLASK_DEBUG") == True:
    YOUR_DOMAIN = 'http://127.0.0.1:5000/membership'

'''
█▀█ █▀▀ █▀ ▀█▀   ▄▀█ █▀█ █
█▀▄ ██▄ ▄█ ░█░   █▀█ █▀▀ █

DEVELOPED AND DESIGNED BY JOHN SEONG
'''

bp = Blueprint('main', __name__, static_folder='../client/build', static_url_path='/')

limiter = Limiter(
    current_app,
    key_func=get_remote_address,
    default_limits=["200 per day", "50 per hour"]
)

# WHAT IS CORS: https://flask-cors.readthedocs.io/en/latest/

CORS(bp, resources={r'/api/*': {'origins': '*'}})

PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# For React Router Redirection Purposes...
@bp.app_errorhandler(404)   
@limiter.exempt
def not_found(e):   
    '''
    This function is used to redirect the user to the React Router page

    Parameters
    ----------
    e: Exception
        The exception that was raised

    Returns
    -------
    DOM File
        Returns a HTML script that contains the visual elements of the website
    '''
    return bp.send_static_file('index.html')

@bp.route('/') 
@limiter.exempt
def serve():
    '''
    This function is executed in root directory,
    redirecting to the static HTML file generated by React front-end framework
    
    Parameters
    ----------
    None

    Returns
    -------
    DOM File
        Returns a HTML script that contains the visual elements of the website
    '''
    return bp.send_static_file('index.html')

@bp.route('/api/atom-by-quantum-number/<data>', methods=['GET'])
@limiter.limit("30 per minute")
def compute_atom_by_quantum_no(data):
    '''
    This function is used to compute the atom's data by the quantum numbers
    
    Parameters
    ----------
    quantum_no: str
        The quantum numbers of the atom

    Returns
    -------
    JSON
        Returns a JSON file containing the atom's data
    '''
    dataList = data.split('-')

    n = int(dataList[0])
    l = int(dataList[1])
    m = int(dataList[2])
    name = int(dataList[3])


    return_value = atomic_orbital.plot_atomic_orbital(name, n, l, m)
    return return_value

@bp.route('/api/atom/<name>', methods=['GET'])
@limiter.limit("5 per minute")
@cross_origin()
def compute_atom(name):
    '''
    When API call is made, this function executes
    the plot_hydrogen method which computes the
    electron density data for hydrogen atom.
    Not only that, it also automatically saves all the data
    on the Amazon S3 server.
    
    Parameters
    ----------
    name: String
        Contains the name of the element

    Returns
    -------
    JSON Object
        A JSONified dictionary that contains
        the electron density and coordinate data
    '''
    with open('server/quantum_num.json', 'r') as f:
        name_dict = json.load(f)
        current_name = name_dict[name]

        data = atomic_orbital.plot_atomic_orbital(name, current_name["n"], current_name["l"], current_name["m"])
        return data

@bp.route('/api/molecule/<name>', methods=['GET'])
@limiter.limit("5 per minute")
@cross_origin()
def compute_molecule(name):
    '''
    When API call is made, this function executes
    the plot_hydrogen method which computes the
    electron density data for hydrogen atom.
    Not only that, it also automatically saves all the data
    on the Amazon S3 server.
    
    Parameters
    ----------
    name: String
        Contains the name of the element

    Returns
    -------
    JSON Object
        A JSONified dictionary that contains
        the electron density and coordinate data
    '''
    
    data = electron_density.plot_molecule(name)
    return data

@bp.route('/api/load/<name>', methods=['GET'])
@limiter.exempt
@cross_origin()
def load_from_s3(name):
    '''
    When API call is made, this function loads
    the JSON data from the Amazon S3 server
    
    Parameters
    ----------
    name: String
        Contains the name of the element

    Returns
    -------
    JSON Object
        A JSONified dictionary that contains
        the electron density and coordinate data
    '''
    output = os.path.join(PROJECT_ROOT, f'client/src/assets/{name}.json')

    multipart_download_boto3(name, output)
    
    with open(output, 'r') as f:
        data = json.load(f)
        return data

@bp.route('/api/loadSPH/<name>', methods=['GET'])
@limiter.exempt
@cross_origin()
def loadSPH_from_s3(name):
    '''
    When API call is made, this function loads
    the JSON data from the Amazon S3 server
    
    Parameters
    ----------
    name: String
        Contains the name of the element

    Returns
    -------
    JSON Object
        A JSONified dictionary that contains
        the electron density and coordinate data
    '''
    output = os.path.join(PROJECT_ROOT, f'client/src/assets/SPH_{name}.json')

    multipart_download_boto3("SPH_" + name, output)
    
    with open(output, 'r') as f:
        data = json.load(f)
        return data
    
@bp.route('/api/get-articles')
@limiter.exempt
@cross_origin()
def get_articles():
    with open('server/articles.json', 'r') as f:
        articles = json.load(f)

    return jsonify(articles)
    
@bp.route('/api/upload', methods=['POST'])
@limiter.limit("5 per minute")
@cross_origin()
def upload_file():
    if request.method == 'POST':
        if 'file' not in request.files:
            return 'No file uploaded!', 400

        file = request.files['file']
        name = request.form.get('name')

        if file.filename == '':
            return 'No file uploaded!', 400
        
        # Save the file to the server's file system
        file_path = os.path.join('server', file.filename)
        file.save(file_path)

        # Upload the file to S3
        multipart_upload_boto3(name, file_path)

@bp.route('/api/downloadGLB/<key>', methods=['GET'])
@limiter.exempt()
@cross_origin()
def download_glb(key):
    try:
        file_path = f'server/{key}'
        multipart_download_boto3(key, file_path)

        # Change the file extension to .glb
        name, extension = os.path.splitext(file_path)
        new_file_path = f'{name}.glb'
        os.rename(file_path, new_file_path)

        response = make_response(send_file(new_file_path.replace("server/", ""), as_attachment=True))
        response.headers['Content-Disposition'] = f'attachment; filename="{key}"'
        return response

    except ClientError as e:
        print(e)
        return 'Error downloading file from S3!', 500
    

@bp.route('/api/downloadPNG/<key>', methods=['GET'])
@limiter.exempt()
@cross_origin()
def download_png(key):
    try:
        file_path = f'server/{key}'
        multipart_download_boto3(key, file_path)

        # Change the file extension to .png
        name, extension = os.path.splitext(file_path)
        new_file_path = f'{name}.png'
        os.rename(file_path, new_file_path)

        response = make_response(send_file(new_file_path.replace("server/", ""), as_attachment=True))
        response.headers['Content-Disposition'] = f'attachment; filename="{key}"'
        return response

    except ClientError as e:
        print(e)
        return 'Error downloading file from S3!', 500
    
@bp.route('/api/downloadSTL/<key>', methods=['GET'])
@limiter.exempt()
@cross_origin()
def download_stl(key):
    try:
        file_path = f'server/{key}'
        multipart_download_boto3(key, file_path)

        # Change the file extension to .png
        name, extension = os.path.splitext(file_path)
        new_file_path = f'{name}.stl'
        os.rename(file_path, new_file_path)

        response = make_response(send_file(new_file_path.replace("server/", ""), as_attachment=True))
        response.headers['Content-Disposition'] = f'attachment; filename="{key}"'
        return response

    except ClientError as e:
        print(e)
        return 'Error downloading file from S3!', 500

@bp.route('/api/create-checkout-session', methods=['POST'])
@limiter.exempt()
@cross_origin()
def create_checkout_session():
    price_id = request.form.get('priceId')
    app_user_id = request.form.get('appUserId')

    try:
        checkout_session = stripe.checkout.Session.create(
            client_reference_id=app_user_id,
            line_items=[
                {
                    # Provide the exact Price ID (for example, pr_1234) of the product you want to sell
                    'price': price_id,
                    'quantity': 1,
                },
            ],
            mode='subscription',
            success_url=YOUR_DOMAIN + '?success=true',
            cancel_url=YOUR_DOMAIN + '?canceled=true',
            automatic_tax={'enabled': True},
        )

    except Exception as e:
        return str(e)

    return redirect(checkout_session.url, code=303)

@bp.route('/api/create-portal-session', methods=['POST'])
@limiter.exempt()
@cross_origin()
def customer_portal():
    # Get app_user_id from the request form
    app_user_id = request.form.get('appUserId')

    # Retrieve the checkout_session_id from Firestore using app_user_id
    doc_ref = db.collection('customers-web').document(app_user_id)
    doc = doc_ref.get()
    if doc.exists:
        checkout_session_id = doc.get('checkout_session_id')
    else:
        return "No such document", 404

    # Retrieve the customer ID using the checkout_session_id
    checkout_session = stripe.checkout.Session.retrieve(checkout_session_id)

    # This is the URL to which the customer will be redirected after they are
    # done managing their billing with the portal.
    return_url = YOUR_DOMAIN

    portalSession = stripe.billing_portal.Session.create(
        customer=checkout_session.customer,
        return_url=return_url,
    )
    return redirect(portalSession.url, code=303)

@bp.route('/api/webhook', methods=['POST'])
@limiter.exempt()
@cross_origin()
def webhook_received():
    webhook_secret = STRIPE_WEBHOOK_SECRET

    if request.get_data(as_text=True):
        try:
            request_data = json.loads(request.get_data(as_text=True))
        except json.JSONDecodeError as e:
            current_app.logger.error(f"JSONDecodeError: {e}")
            return jsonify({'status': 'error', 'message': 'Invalid or empty JSON received'})
    else:
        return jsonify({'status': 'error', 'message': 'Empty request data received'})

    if webhook_secret:
        try:
            signature = request.headers['STRIPE_SIGNATURE']
        except KeyError:
            current_app.logger.error("STRIPE_SIGNATURE header not found")
            return jsonify({'status': 'error', 'message': 'STRIPE_SIGNATURE header not found'})

        try:
            event = stripe.Webhook.construct_event(
                payload=request.get_data(as_text=True), sig_header=signature, secret=webhook_secret)
            data = event['data']
        except Exception as e:
            current_app.logger.error(f"Exception: {e}")
            return jsonify({'status': 'error', 'message': 'Signature verification failed'})
        event_type = event['type']
    else:
        data = request_data['data']
        event_type = request_data['type']
    data_object = data['object']

    current_app.logger.info(f'event {event_type}')

    if event_type == 'checkout.session.completed':
        checkout_session_id = data_object['id']
        customer_id = data_object['client_reference_id']
        subscription_id = data_object['subscription']

        headers = {
            'Content-Type': 'application/json',
            'X-Platform': 'stripe',
            'Authorization': f'Bearer {REVENUECAT_STRIPE_API_KEY}'
        }

        data = {
            'app_user_id': customer_id,
            'fetch_token': subscription_id
        }

        response = requests.post('https://api.revenuecat.com/v1/receipts', headers=headers, json=data)

        if response.status_code == 200:
            current_app.logger.info('🔔 Payment succeeded!')
            doc_ref = db.collection(u'customers-web').document(customer_id)
            doc_ref.set({
                u'checkout_session_id': checkout_session_id
            }, merge=True)
        else:
            current_app.logger.error(f'❌ Payment failed! Status code: {response.status_code}, Response: {response.text}')

    return jsonify({'status': 'success'})

@bp.route('/api/get_subscriber_data/<app_user_id>')
@limiter.exempt()
@cross_origin()
def get_subscriber_data(app_user_id):
    url = f'https://api.revenuecat.com/v1/subscribers/{app_user_id}'
    headers = {
        'Content-Type': 'application/json',
        'Authorization': f'Bearer {REVENUECAT_STRIPE_API_KEY}'
    }
    response = requests.get(url, headers=headers)
    return response.json()

@bp.route('/api/send-email', methods=['POST'])
@limiter.exempt()
@cross_origin()
def contact():
    # Get form data
    name = request.form['name']
    email = request.form['email']
    message = request.form['message']
    
    # Send email
    sg = sendgrid.SendGridAPIClient(api_key=os.environ.get('SENDGRID_API_KEY'))
    from_email = ('johnseong@havit.space', 'John Seong')
    to_email = ('johnseong@havit.space', 'John Seong')
    subject = f"New message from {name}"
    body = f"Name: {name}\nEmail: {email}\n\n{message}"
    mail = Mail(from_email, to_email, subject, body)
    response = sg.send(mail)

    # Return success message
    return "Message sent successfully"

@bp.route('/api/get_chemistry_data', methods=['GET'])
@limiter.exempt()
@cross_origin()
def proxy_request():
    term = request.args.get('term')
    url = f'https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/{term}/JSON'
    response = requests.get(url)
    
    if response.status_code == 200:
        return jsonify(response.json())
    else:
        return jsonify({"error": "Request failed"}), response.status_code

@bp.route('/api/get_chemistry_image', methods=['GET'])
@limiter.exempt()
@cross_origin()
def image_request():
    cid = request.args.get('cid')
    url = f'https://pubchem.ncbi.nlm.nih.gov/image/imgsrv.fcgi?cid={cid}&t=l'
    response = requests.get(url)

    if response.status_code == 200:
        return send_file(BytesIO(response.content), mimetype='image/png')
    else:
        return jsonify({"error": "Image request failed"}), response.status_code

# Define a function to reset the click count in Firebase
def reset_click_count(uid):
    user_ref = db.collection('customers-web').document(uid)
    user_ref.update({'button_click_count': 0})

from apscheduler.triggers.date import DateTrigger

@bp.route('/api/button_click_logged', methods=['POST'])
@limiter.exempt()
@cross_origin()
def handle_button_click():
    user_uid = request.form.get('user_uid')

    current_app.logger.info(f"Selected user: {user_uid}")

    # Check if the document with user_uid exists
    user_ref = db.collection('customers-web').document(user_uid)
    user_data = user_ref.get().to_dict()

    if user_data:
        # Update the existing document
        user_ref.update({'button_click_count': firestore.Increment(1)})
    else:
        # Create a new document with the given user_uid
        user_ref.set({'button_click_count': firestore.Increment(1)}, merge=True)

    # Remove all previous scheduled jobs for the current user
    jobs = scheduler.get_jobs()
    for job in jobs:
       if isinstance(job.trigger, DateTrigger) and job.args and job.args[0] == user_uid:
            scheduler.remove_job(job.id)

    # Add a new job to the scheduler that runs reset_click_count once after 2 hours
    import time

    job_id = f'job_{int(time.time())}'
    scheduler.add_job(id=job_id, func=reset_click_count, args=[user_uid], trigger='date', run_date=datetime.now() + timedelta(hours=2))

    return {'message': 'Button clicked successfully.'}

# Initialize the scheduler
def init_scheduler(app):
    scheduler.init_app(app)

@socketio_bp.route('/socket.io/')
def socketio_route():
    return

@socketio.on('connect', namespace='/socket.io/')
def socketio_connect():
    # Handle connection event
    emit('connected', {'data': 'Connected successfully'})

# SocketIO event handler to retrieve hours left till reset
@socketio.on('get_hours_left_logged')
def get_hours_left(user_uid):
    user_ref = db.collection('customers-web').document(user_uid).get()
    click_count = user_ref.get('button_click_count')

    if click_count is not None and click_count > 0:
        # Calculate hours left till reset
        last_reset_time = user_ref.get('last_reset_time')
        if last_reset_time is not None:
            hours_passed = (datetime.now() - last_reset_time).total_seconds() / 3600
            hours_left = 2 - hours_passed
            if hours_left > 0:
                emit('hours_left', hours_left)
            else:
                emit('hours_left', 0)
        else:
            emit('hours_left', 0)
    else:
        emit('hours_left', 0)

@socketio.on('get_button_click_number_logged')
def get_button_click_number(user_uid):
    # Retrieve the button click number for the user
    user_ref = db.collection('customers-web').document(user_uid)
    user_data = user_ref.get().to_dict()
    button_click_count = user_data.get('button_click_count', 0)

    # Emit the button click number to the client
    emit('button_click_number', button_click_count)

'''
----------------------------------------------------------------

:: TIPS & TRICKS FOR INSTALLING GPAW (PSEUDO WAVEFUNCTION GENERATOR/CALCULATOR) IN A MACOS ENVIRONMENT ::

A MUST! ADD CONDA BUILDPACK TO HEROKU: https://elements.heroku.com/buildpacks/heroku-python/conda-buildpack

ALSO DO NOT PLACE GPAW IN THE REQUIREMENTS.TXT FILE; MOVE IT TO CONDA-REQUIREMENTS.TXT AS IT REQUIRES C DEPENDENCIES

Make sure you download libxc through brew and execute all the export commands on macOS:
https://gitlab.com/gpaw/gpaw/-/merge_requests/830/diffs#43b43d9adc91f1e38f6d186a1d173d83aaea27fd

After installing libxc through brew...

ON MAC:
1. export C_INCLUDE_PATH=/opt/homebrew/Cellar/libxc/5.2.3/include
2. export LIBRARY_PATH=/opt/homebrew/Cellar/libxc/5.2.3/lib
3. export LD_LIBRARY_PATH=/opt/homebrew/Cellar/libxc/5.2.3/lib
4. export LDFLAGS="-L/opt/homebrew/opt/openblas/lib"
5. export CPPFLAGS="-I/opt/homebrew/opt/openblas/include"

ON UBUNTU:
https://gitlab.com/gpaw/gpaw/-/blob/master/doc/platforms/Linux/ubuntu.rst#id1

After all this, execute pip3 install gpaw

----------------------------------------------------------------

:: HELPFUL LINKS ::

https://www.brown.edu/Departments/Engineering/Labs/Peterson/tips/ElectronDensity/index.html

----------------------------------------------------------------

:: HOW TO ACCESS HEROKU CLI BASH TERMINAL ::

heroku login
heroku ps:exec --app=scoreboard-backend-dev

---------------------------------------------------------------- 

:: HOW TO DOCKERIZE A REACT + FLASK STACK (REPLACE PATH WITH YOUR PROJECT PATH, DEFAULT SET TO MAC STANDARD)::

https://blog.miguelgrinberg.com/post/how-to-dockerize-a-react-flask-project
https://developer.okta.com/blog/2020/06/24/heroku-docker-react#deploy-your-react-app-to-heroku

BUILD DOCKER FILE COMMAND — SERVER:
docker build -f /Users/johnseong/Documents/GitHub/ElectronVisualized/Dockerfile.api -t electronvisualized-api .
[OPTIONAL] docker run --rm -p 5000:5000 electronvisualized-api

BUILD DOCKER FILE COMMAND — CLIENT:
docker build -f /Users/johnseong/Documents/GitHub/ElectronVisualized/Dockerfile.client -t electronvisualized-client .

DOCKER-COMPOSE:
docker-compose build
docker-compose up

HEROKU:
heroku stack:set container
heroku container:push --recursive
heroku container:release web worker // If it's DockerFile.web and DockerFile.worker...

----------------------------------------------------------------

:: ADDITIONAL REALLY HELPFUL LINKS ::

https://dev.to/ejach/how-to-deploy-a-python-flask-app-on-heroku-using-docker-mpc

HOW TO SET UP FOR MACOS & MAC APP STORE DISTRIBUTION:
https://stackoverflow.com/questions/72194861/electron-macos-app-not-available-for-testing-in-testflight

WEBRTC FLASK + REACT TUTORIAL:
https://www.100ms.live/blog/python-react-webrtc-app
https://developer.okta.com/blog/2021/07/14/socket-io-react-tutorial

FLASK-REACT JWT AUTHENTICATION:
https://yasoob.me/posts/how-to-setup-and-deploy-jwt-auth-using-react-and-flask/

----------------------------------------------------------------
'''